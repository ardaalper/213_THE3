#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>

//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    /* TODO */
    return w1*alpha + w0*(1-alpha);
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    /* TODO */
    int size=vertexList.size();
    
    for(int i=0;i<size;i++){
        if(vertexList[i].name==vertexName){
            throw DuplicateVertexException(vertexName);
        } 
    }
    
    GraphVertex neww;
    neww.name=vertexName;
    vertexList.push_back(neww);
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    /* TODO */
    int index=0;
    int size=vertexList.size();
    int flag=1;
    
    for(;index<size;index++){
        if(vertexList[index].name == vertexName){
            flag=0;
            break;
        }
    }
    
    if(flag){
        throw VertexNotFoundException(vertexName);
    }
    
    for(int i=0;i<size;i++){
        int j=0;
        while(j<vertexList[i].edges.size()){
            if(vertexList[i].edges[j].endVertexIndex==index){
                vertexList[i].edges.erase(vertexList[i].edges.begin() + j);
            }
            else{
                j++;
            }
        }
    }
    vertexList.erase(vertexList.begin()+index);
}
/*This function tries to set an edge between two vertices, namely “vertexFromName” and “vertexToN
ame”. If either of these vertices does not exist, the function should throw “VertexNotFoundEx
ception”. If an edge named “edgeName” exists between these two vertices the function should
 throw SameNamedEdgeException.*/
void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    /* TODO */
    int flag1=1;
    int flag2=1;
    int size=vertexList.size();
    int index1=0;
    int index2=0;
    
    for (; index1 < size; index1++){
        if (vertexList[index1].name == vertexFromName) {
            flag1=0;
            break;
        }
    }
    for (; index2 < size; index2++){
        if (vertexList[index2].name == vertexToName) {
            flag2=0;
            break;
        }
    }
    if(flag1){
        throw VertexNotFoundException(vertexFromName);
    }
    if(flag2){
        throw VertexNotFoundException(vertexToName);
    }
    
    for(int j=0;j<vertexList[index1].edges.size();j++){
        if(vertexList[index1].edges[j].name==edgeName && vertexList[index1].edges[j].endVertexIndex==index2){
            throw SameNamedEdgeException(edgeName,vertexFromName,vertexToName);
        }
    }
    
    GraphEdge neww;
    
    neww.weight[0] = weight0;
    neww.weight[1] = weight1;
    neww.endVertexIndex = index2;
    neww.name = edgeName;
    
    vertexList[index1].edges.push_back(neww);
    
}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    /* TODO */
    int flag1=1;
    int flag2=1;
    int size=vertexList.size();
    int index1=0;
    int index2=0;
    
    for (; index1 < size; index1++){
        if (vertexList[index1].name == vertexFromName) {
            flag1=0;
            break;
        }
    }
    for (; index2 < size; index2++){
        if (vertexList[index2].name == vertexToName) {
            flag2=0;
            break;
        }
    }
    if(flag1){
        throw VertexNotFoundException(vertexFromName);
    }
    if(flag2){
        throw VertexNotFoundException(vertexToName);
    }
    /////////////////////////////////////////////////////////
    int flagg = 1;
    
    int i=0;
    for(;i<vertexList[index1].edges.size();i++){
        if(vertexList[index1].edges[i].endVertexIndex == index2 && vertexList[index1].edges[i].name==edgeName){
            flagg = 0;
            break;
        }
    }
    if(flagg){
        throw EdgeNotFoundException(vertexFromName,edgeName);
    }
    vertexList[index1].edges.erase(vertexList[index1].edges.begin()+i);
    
    
    
}

bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    /* TODO */

    bool result=false;
    int flag1=1;
    int flag2=1;
    int size=vertexList.size();
    int index1=0;
    int index2=0;
    
    for (; index1 < size; index1++){
        if (vertexList[index1].name == vertexNameFrom) {
            flag1=0;
            break;
        }
    }
    for (; index2 < size; index2++){
        if (vertexList[index2].name == vertexNameTo) {
            flag2=0;
            break;
        }
    }
    if(flag1){
        throw VertexNotFoundException(vertexNameFrom);
    }
    if(flag2){
        throw VertexNotFoundException(vertexNameTo);
    }


    //////////////////////////////////////////////////////////
    
    std::vector<int> previous(size, -1);
    
    std::vector<float> distance(size, 99999);
    distance[index1] = 0; 

    MinPairHeap<float, int> pque;
    for (int i=0; i<size; i++) {
        pque.push({distance[i], i});
    }

    while (1) {
        if(pque.empty()) break;

        Pair<float, int> currentVertexPair = pque.top();
        pque.pop();
        int CurrVerIndex = currentVertexPair.value;
        
        int size=vertexList[CurrVerIndex].edges.size();
        for (int i=0; i<size; i++) {
            const GraphEdge& adjacent = vertexList[CurrVerIndex].edges[i];
            
            float newDist = distance[CurrVerIndex] + Lerp(adjacent.weight[0], adjacent.weight[1], heuristicWeight);
            int neighborindex = adjacent.endVertexIndex;
            
            if (newDist < distance[neighborindex]) {
                distance[neighborindex] = newDist;
                previous[neighborindex] = CurrVerIndex;
                pque.push({distance[neighborindex], neighborindex});
            }
        }
    }

    if (distance[index2] < 99999) {

        int currindex = index2;
        while (currindex != -1) {

            orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(), currindex);
        
            if (previous[currindex] != -1) {
                int edgeIdx = edgeIndex(vertexList[previous[currindex]].edges, currindex);
                if (edgeIdx != -1) {
                    orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(), edgeIdx);
                }
            }

            currindex = previous[currindex];
        }
        result=true;
        
    }
        return result;
        
}

bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    int flag1=1;
    int flag2=1;
    int size=vertexList.size();
    int index1=0;
    int index2=0;
    
    for (; index1 < size; index1++){
        if (vertexList[index1].name == vertexNameFrom) {
            flag1=0;
            break;
        }
    }
    for (; index2 < size; index2++){
        if (vertexList[index2].name == vertexNameTo) {
            flag2=0;
            break;
        }
    }
    if(flag1){
        throw VertexNotFoundException(vertexNameFrom);
    }
    if(flag2){
        throw VertexNotFoundException(vertexNameTo);
    }
    ///////////////////////////////////////////////////////////////////////////
    std::vector<int> previous(size, -1);
    std::vector<float> distance(size, 99999);

    distance[index1] = 0;

    MinPairHeap<float, int> pque;
    for (int i=0; i<size; i++) {
        pque.push({distance[i], i});
    }

    while (1) {
        if(pque.empty()){
            break;
        }
        int currentVIndex = pque.top().value;
        pque.pop();


        for (int j=0; j<vertexList[currentVIndex].edges.size(); j++) {
            GraphEdge adjacent = vertexList[currentVIndex].edges[j];
            int komsuindex = adjacent.endVertexIndex;


            bool flag = true;
            for (int k=0; k<edgeNames.size(); k++) {
                if (edgeNames[k] == adjacent.name) {
                    flag = false;
                }
            }

            if (flag) {
                float newDist = distance[currentVIndex] + Lerp(adjacent.weight[0], adjacent.weight[1], heuristicWeight);

                if (newDist < distance[komsuindex]) {
                    distance[komsuindex] = newDist;
                    previous[komsuindex] = currentVIndex;
                    pque.push({distance[komsuindex], komsuindex});
                }  
            }

        }
    }


    if (distance[index2] < 99999) {
        int currVIn = index2;
        while (currVIn != -1) {
            orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(), currVIn);

            if (previous[currVIn] != -1) {
                int edgeIdx = edgeIndex(vertexList[previous[currVIn]].edges, currVIn);
                orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(), edgeIdx);
            }

            currVIn = previous[currVIn];
        }
        return true;
    }

    return false;

}
int MultiGraph::BiDirectionalEdgeCount() const
{
    int count = 0;

    for (int i = 0; i < vertexList.size(); i++) {

        for (int j = 0; j < vertexList[i].edges.size(); j++) {

            int sizeee=vertexList[vertexList[i].edges[j].endVertexIndex].edges.size();
            for (int k = 0; k < sizeee; k++) {
                if (vertexList[vertexList[i].edges[j].endVertexIndex].edges[k].endVertexIndex == i){
                    if( vertexList[vertexList[i].edges[j].endVertexIndex].edges[k].name == vertexList[i].edges[j].name) {
                        count++;
                    }
                }
            }
        }
    }
    return count / 2;
}


///////////////DEĞİŞTİRDEĞİŞTİR///////////////DEĞİŞTİRDEĞİŞTİR///////////////DEĞİŞTİRDEĞİŞTİR
int MultiGraph::MaxDepthHelper(const std::string& vertexName,
                                          const std::string& edgeName,
                                          std::vector<bool>& gittik) const
{

    int flag=1;
    int size=vertexList.size();
    int index=0;
    for (; index < size; index++){
        if (vertexList[index].name == vertexName) {
            flag=0;
            break;
        }
    }
    if(flag){
        throw VertexNotFoundException(vertexName);
    }


    gittik[index] = true;

    int max = 0;

    for (int j=0; j < vertexList[index].edges.size(); j++) {
        if (!gittik[vertexList[index].edges[j].endVertexIndex] && vertexList[index].edges[j].name == edgeName) {
            int depth = MaxDepthHelper(vertexList[vertexList[index].edges[j].endVertexIndex].name, edgeName, gittik)+1;
            if (depth>max) {
                max=depth;
            }
        }
    }

    gittik[index] = false;

    return max;
}

int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName,
                                    const std::string& edgeName) const
{
    int flag=1;
    int size=vertexList.size();
    int index=0;
    for (; index<size; index++){
        if (vertexList[index].name == vertexName) {
            flag=0;
            break;
        }
    }
    if(flag){
        throw VertexNotFoundException(vertexName);
    }

    std::vector<bool> gittik(size, false);

    return MaxDepthHelper(vertexName, edgeName, gittik);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
int MultiGraph::vertexIndex(const std::string& vertexName, const std::vector<GraphVertex>& vertexList) const{
    for (int i=0; i<vertexList.size(); i++) {
        if (vertexList[i].name == vertexName) {
            return i;
        }
    }
}
int MultiGraph::edgeIndex(const std::vector<GraphEdge>& edges, int endVertexIndex) const{
    for (int i=0; i<edges.size(); i++) {
        if (edges[i].endVertexIndex == endVertexIndex) {
            return i;
        }
    }
    return -1;
}
std::vector<GraphVertex> MultiGraph::getVertexList(){
    return vertexList;
}